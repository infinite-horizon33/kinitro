"""
Custom logging implementation.
"""

import logging
import os
import re
import sys
from dataclasses import dataclass
from enum import StrEnum
from pathlib import Path
from typing import Optional, Union

from colorama import Back, Fore, Style, init

# Initialize colorama for cross-platform color support
init(autoreset=True)


TRACE_LEVEL_NUM = logging.DEBUG - 5

if not hasattr(logging, "TRACE"):
    logging.TRACE = TRACE_LEVEL_NUM
    logging.addLevelName(logging.TRACE, "TRACE")


def _trace(self: logging.Logger, message, *args, **kwargs):
    if self.isEnabledFor(logging.TRACE):
        self._log(logging.TRACE, message, args, **kwargs)


if not hasattr(logging.Logger, "trace"):
    logging.Logger.trace = _trace  # type: ignore[attr-defined]


class LogLevel(StrEnum):
    TRACE = "TRACE"
    DEBUG = "DEBUG"
    INFO = "INFO"
    WARNING = "WARNING"
    ERROR = "ERROR"
    CRITICAL = "CRITICAL"

    @property
    def level(self) -> int:
        """Maps the LogLevel enum to the corresponding logging module constant.

        Returns
        -------
        int
            The logging module constant for the log level.
        """
        return {
            LogLevel.TRACE: logging.TRACE,
            LogLevel.DEBUG: logging.DEBUG,
            LogLevel.INFO: logging.INFO,
            LogLevel.WARNING: logging.WARNING,
            LogLevel.ERROR: logging.ERROR,
            LogLevel.CRITICAL: logging.CRITICAL,
        }[self]


class ColoredFormatter(logging.Formatter):
    """Custom logging formatter to add colors based on log level."""

    LEVEL_COLORS = {
        LogLevel.TRACE: Fore.MAGENTA,
        LogLevel.DEBUG: Fore.CYAN,
        LogLevel.INFO: Fore.GREEN,
        LogLevel.WARNING: Fore.YELLOW,
        LogLevel.ERROR: Fore.RED,
        LogLevel.CRITICAL: Fore.RED + Back.WHITE,
    }

    def format(self, record: logging.LogRecord) -> str:
        try:
            log_level = LogLevel(record.levelname)
            color = self.LEVEL_COLORS.get(log_level, Fore.WHITE)
        except ValueError:
            color = Fore.WHITE  # Default color for unknown levels

        # Apply color to the level name
        levelname_color = f"{color}{Style.BRIGHT}{record.levelname}{Style.RESET_ALL}"

        # Create a copy of the record to avoid modifying the original
        record_copy = logging.LogRecord(
            name=record.name,
            level=record.levelno,
            pathname=record.pathname,
            lineno=record.lineno,
            msg=record.msg,
            args=record.args,
            exc_info=record.exc_info,
            func=record.funcName,
            sinfo=record.stack_info,
        )
        record_copy.levelname = levelname_color

        # Format the message using the parent class
        formatted_message = super().format(record_copy)

        return formatted_message


_DEFAULT_COLORED_FORMAT = (
    f"{Fore.BLUE}%(asctime)s.%(msecs)03d{Style.RESET_ALL} | "
    f"%(levelname)s | "
    f"{Fore.BLUE}%(name)s{Style.RESET_ALL}:"
    f"{Fore.BLUE}%(funcName)s{Style.RESET_ALL}:"
    f"{Fore.BLUE}%(lineno)d{Style.RESET_ALL} - "
    f"%(message)s"
)

_ANSI_ESCAPE_RE = re.compile(r"\x1b\[[0-9;]*m")


@dataclass
class _LoggerSettings:
    log_format: str
    date_format: str


_LOGGING_STATE: dict[str, Optional[Path]] = {
    "log_file_path": Path(os.getenv("LOG_FILE")).expanduser()
    if os.getenv("LOG_FILE")
    else None
}
_MANAGED_LOGGERS: dict[logging.Logger, _LoggerSettings] = {}


def _strip_ansi(value: str) -> str:
    return _ANSI_ESCAPE_RE.sub("", value)


def _build_handlers(
    level: int, log_format: str, date_format: str
) -> list[logging.Handler]:
    stream_handler = logging.StreamHandler(sys.stdout)
    stream_handler.setLevel(level)
    stream_handler.setFormatter(ColoredFormatter(log_format, datefmt=date_format))
    handlers: list[logging.Handler] = [stream_handler]

    log_path = _LOGGING_STATE["log_file_path"]
    if log_path:
        log_path.parent.mkdir(parents=True, exist_ok=True)
        file_handler = logging.FileHandler(log_path, encoding="utf-8", mode="a")
        file_handler.setLevel(level)
        plain_format = logging.Formatter(_strip_ansi(log_format), datefmt=date_format)
        file_handler.setFormatter(plain_format)
        handlers.append(file_handler)

    return handlers


def _clear_handlers(logger: logging.Logger):
    for handler in logger.handlers:
        try:
            handler.close()
        except Exception:
            pass
    logger.handlers.clear()


def _apply_handlers(logger: logging.Logger, log_format: str, date_format: str) -> None:
    level = logger.level or logging.INFO
    _clear_handlers(logger)
    for handler in _build_handlers(level, log_format, date_format):
        logger.addHandler(handler)


def configure_logging(log_file_path: Optional[Union[str, os.PathLike[str]]] = None):
    """Configure global logging behavior.

    Parameters
    ----------
    log_file_path: Optional[Union[str, os.PathLike[str]]]
        When provided, logs are additionally written to this file.
        Passing None disables file logging.
    """

    if log_file_path:
        path = Path(log_file_path).expanduser()
        path.parent.mkdir(parents=True, exist_ok=True)
        _LOGGING_STATE["log_file_path"] = path
    else:
        _LOGGING_STATE["log_file_path"] = None

    for logger, settings in _MANAGED_LOGGERS.items():
        _apply_handlers(logger, settings.log_format, settings.date_format)


def get_logger(
    name: str,
    log_format: Optional[str] = None,
    date_format: Optional[str] = None,
    handlers: Optional[list[logging.Handler]] = None,
) -> logging.Logger:
    """Initializes and returns a logger with the specified configurations,
    reading the log level from the environment variable LOG_LEVEL.

    Parameters
    ----------
    name: str
        The name of the logger.
    log_format: Optional[str]
        Custom format string for log messages. If not provided, a default format is used.
    date_format: Optional[str]
        Custom date format string. If not provided, defaults to "%Y-%m-%d %H:%M:%S".
    handlers: Optional[list[logging.Handler]]
        A list of logging handlers to attach to the logger. If not provided, a StreamHandler is used.

    Returns
    -------
    logging.Logger
        Configured logger instance.
    """

    # Retrieve log level from environment variable, default to INFO
    env_log_level = os.getenv("LOG_LEVEL", "INFO").upper()
    try:
        log_level = LogLevel(env_log_level)
    except ValueError:
        # Initialize a temporary logger to log the warning before main logger is set
        temp_logger = logging.getLogger("temp_logger")
        temp_logger.setLevel(logging.INFO)
        temp_handler = logging.StreamHandler(sys.stdout)
        temp_formatter = logging.Formatter(
            f"{Fore.YELLOW}WARNING{Style.RESET_ALL}: "
            f"Invalid LOG_LEVEL '{env_log_level}' specified. Defaulting to INFO level."
        )
        temp_handler.setFormatter(temp_formatter)
        temp_logger.addHandler(temp_handler)
        temp_logger.warning(
            f"Invalid LOG_LEVEL '{env_log_level}' specified. Defaulting to INFO level."
        )
        log_level = LogLevel.INFO

    logger = logging.getLogger(name)
    logger.setLevel(log_level.level)

    # Clear existing handlers to prevent duplicate logs
    if logger.hasHandlers():
        logger.handlers.clear()

    # Define default log format if not provided
    if not log_format:
        log_format = _DEFAULT_COLORED_FORMAT

    # Define default date format if not provided
    if not date_format:
        date_format = "%Y-%m-%d %H:%M:%S"

    managed = handlers is None

    # If no handlers are provided, use default stream (and optional file) handlers
    if not handlers:
        handlers = _build_handlers(log_level.level, log_format, date_format)
    else:
        _MANAGED_LOGGERS.pop(logger, None)

    _clear_handlers(logger)
    for handler in handlers:
        logger.addHandler(handler)

    if managed:
        _MANAGED_LOGGERS[logger] = _LoggerSettings(
            log_format=log_format, date_format=date_format
        )

    logger.debug(f"Logger '{name}' initialized with level {log_level}")
    return logger
